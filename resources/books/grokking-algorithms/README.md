# Grokking Algorithms - Aditya Y. Bhargava

A practical guide to algorithms and data structures with clear explanations and visual examples.

## Table of Contents

### Chapter 4: Quicksort
- **File**: `chapter-4-quicksort.md`
- **Topics**: Recursion, Divide & Conquer, Quicksort algorithm
- **Exercises**: Recursive sum, count, max functions
- **Key Concepts**: Base cases, recursive cases, binary search analysis

## Book Structure

This book covers fundamental algorithms and data structures with a focus on:
- Clear explanations with visual diagrams
- Practical examples and exercises
- Performance analysis (Big O notation)
- Real-world applications

## Reading Notes

### Chapter 4 Highlights
- **Recursion**: Functions that call themselves with base and recursive cases
- **Divide & Conquer**: Break problems into smaller subproblems
- **Quicksort**: Efficient sorting algorithm using divide & conquer
- **Base Cases**: Smallest solvable subproblems that stop recursion

### Key Takeaways
1. Every recursive function needs a base case to prevent infinite loops
2. Divide & conquer algorithms often have O(log n) or O(n log n) complexity
3. Understanding base cases is crucial for designing recursive solutions
4. Binary search is a classic divide & conquer algorithm

## Future Chapters to Add

- Chapter 1: Introduction to Algorithms
- Chapter 2: Selection Sort
- Chapter 3: Recursion
- Chapter 5: Hash Tables
- Chapter 6: Breadth-First Search
- Chapter 7: Dijkstra's Algorithm
- Chapter 8: Greedy Algorithms
- Chapter 9: Dynamic Programming
- Chapter 10: K-Nearest Neighbors
- Chapter 11: Where to Go Next

## Study Approach

1. **Read the chapter** with focus on visual explanations
2. **Implement exercises** in your preferred programming language
3. **Analyze complexity** using Big O notation
4. **Practice variations** of the algorithms
5. **Connect to real-world** applications mentioned in the book
