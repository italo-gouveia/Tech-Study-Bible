# Grokking Algorithms - Aditya Y. Bhargava

A practical guide to algorithms and data structures with clear explanations and visual examples.

**Status**: ✅ **COMPLETED**

## Table of Contents

### Chapter 4: Quicksort
- **File**: `chapter-4-quicksort.md`
- **Topics**: Recursion, Divide & Conquer, Quicksort algorithm
- **Exercises**: Recursive sum, count, max functions
- **Key Concepts**: Base cases, recursive cases, binary search analysis

### Chapter 5: Hash Tables
- **File**: `chapter-5-hash-tables.md`
- **Topics**: Hash tables, hash functions, collision resolution
- **Exercises**: Hash function consistency analysis
- **Key Concepts**: Hash function properties, chaining, open addressing

### Chapter 6: Breadth-First Search
- **File**: `chapter-6-breadth-first-search.md`
- **Topics**: Graph algorithms, BFS, shortest path problems

### Chapter 7: Dijkstra's Algorithm
- **File**: `chapter-7-dijkstra.md`
- **Topics**: Weighted graphs, shortest path algorithm, greedy approach

### Chapter 8: Greedy Algorithms
- **File**: `chapter-8-greedy-algorithms.md`
- **Topics**: Greedy strategy, optimization problems, approximation algorithms

### Chapter 9: Dynamic Programming
- **File**: `chapter-9-dynamic-programming.md`
- **Topics**: Memoization, overlapping subproblems, optimal substructure

### Chapter 10: K-Nearest Neighbors
- **File**: `chapter-10-k-nearest-neighbors.md`
- **Topics**: Machine learning basics, classification, regression

### Chapter 11: Where to Go Next
- **File**: `chapter-11-next-steps.md`
- **Topics**: Further learning resources, advanced topics, practice recommendations

## Book Structure

This book covers fundamental algorithms and data structures with a focus on:
- Clear explanations with visual diagrams
- Practical examples and exercises
- Performance analysis (Big O notation)
- Real-world applications

## Reading Notes

### Chapter 4 Highlights
- **Recursion**: Functions that call themselves with base and recursive cases
- **Divide & Conquer**: Break problems into smaller subproblems
- **Quicksort**: Efficient sorting algorithm using divide & conquer
- **Base Cases**: Smallest solvable subproblems that stop recursion

### Chapter 5 Highlights
- **Hash Tables**: Fast O(1) average time complexity for lookups
- **Hash Functions**: Must be consistent, fast, and distribute keys evenly
- **Collision Resolution**: Chaining and open addressing strategies
- **Consistency**: Hash functions must return same output for same input

### Key Takeaways
1. Every recursive function needs a base case to prevent infinite loops
2. Divide & conquer algorithms often have O(log n) or O(n log n) complexity
3. Understanding base cases is crucial for designing recursive solutions
4. Binary search is a classic divide & conquer algorithm
5. Hash tables provide O(1) average time complexity for fast lookups
6. Hash function consistency is essential for reliable hash table behavior
7. Collision resolution strategies balance performance and memory usage

## Completed Chapters

- ✅ Chapter 4: Quicksort
- ✅ Chapter 5: Hash Tables
- ✅ Chapter 6: Breadth-First Search
- ✅ Chapter 7: Dijkstra's Algorithm
- ✅ Chapter 8: Greedy Algorithms
- ✅ Chapter 9: Dynamic Programming
- ✅ Chapter 10: K-Nearest Neighbors
- ✅ Chapter 11: Where to Go Next

**Note**: Chapters 1-3 (Introduction, Selection Sort, Recursion) were covered as foundational concepts throughout the study.

## Study Approach

1. **Read the chapter** with focus on visual explanations
2. **Implement exercises** in your preferred programming language
3. **Analyze complexity** using Big O notation
4. **Practice variations** of the algorithms
5. **Connect to real-world** applications mentioned in the book
